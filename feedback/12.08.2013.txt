Данный текст не претендует на принадлежность к русскому языку. Если какие-то замечания противоречат формулировке заданий на багтрекере, то прошу об этом сообщить.

Не совсем понимаю откуда появился ItemListDelegate для отображения последовательности чисел. В настоящий момент к такому функционалу требования не было. Программы пишутся для решения реальных задач и в случае каких-нибудь реальных данных вроде 20 тысяч последовательностей, каждая длинной от 1 до 700 элементов(это типичная история продаж у реальных пользователей) отображение всех последотательностей в списке никому не нужно.

PointList::appendInc аналогичен оператору << у QList. Лучше всего использовать наиболее растространнёные именя для методов и операторов. В случае использования << можно наследовать PointList от почти чего угодно, без крупных изменений в коде.

Не понятна мотивация наследования от PointList от QList. У PointList от этого появляется куча методов, которые никогда не будут использованы, но при этом остаются доступны. Кроме того появляется возможность привести PointList к QList, что потенциально может привести к очень сложно обнаруживаемым багам. Для AnalysisResults это менее критично, так как там нету дополнительных полей.

Наличие метода PointList::appendInc позволяет изменить экземпляр PointList::appendInc в любой части программы. Без крайней необходимости таких методов лучше избегать. Пока можно обойтись конструктором от QList. Советую погуглить по слову immutable.

В PointList есть методы типа setID и isSetID. Тут нужно спросит самого себя, нужно ли давать возможность вообще хоть как-то создавать PointList без указания ID. Конструктор по умолчанию бывает нужен для использования в различных структурах, но тогда лучше сделать метод isValid, определяющий можно ли работать с экземпляром PointList.

Плохие имена для аргументов методов. Например PointList &PointList::appendInc(const Point &t).

Тест TAnalysisTableModel::TestAddRemove() проверяет ещё результаты проведения анализа. Это лишнее.

Тестирование методов AnalysisTableModel::data очень сложное. Двойные циклы с заполенение каких-то структур для инит тестов не очень подходят. Лучше добавить методо  AnalysisTableModel::setResult и обойтись одним вызовом AnalysisTableModel::data за весь тест. 

AnalysisTableModel::containsPointList можно написать проще. 

В  AnalysisTableModel::addPointList нужно понимать, не происходит ли что-то лишнее. Не будет ли логика удаления старой ЧП и заменой её новой с тем же ID просто проверкой на уже существующую ЧП в таблице. О возможности существования в программе двух разных ЧП с одним и тем же ID ничего оговорено не было.

Не понимаю что это за idHash_ такой в AnalysisTableModel.

Не нашел явных тестов на удаление и добавление ЧП в AnalysisTableModel.

В Widget(опять слишком абстрактное имя для класса) очень нискоуровневая интеграция списка ЧП и таблицы с анализами друг с другом. Лучше создать собственные сигналы типа AnalysisTableModel::itemActivated(const ID &item) и слоты типа Widget::addItem(const ID &item). Прямого взаимодействия с индексами лучше избегать, так как это сильно разрушает абстракцию. Название Widget - плохая абстракция. Сигналы и слоты описывающие предметную область - хорошая абстракция.

Замечания для AnalysisTableModel следует учесть и для ItemListModel тоже.

Я не предполагал пока, что в ItemListModel будут манипуляции только с идентификарами ЧП, поэтому тесты с использованием SequencePointList. 