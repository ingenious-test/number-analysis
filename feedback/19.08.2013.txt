Данный текст не претендует на принадлежность к русскому языку. Если какие-то замечания противоречат формулировке заданий на багтрекере, то прошу об этом сообщить.

Не надо злоупотреблять тайпдефами. Какой-то типа следует выделять в тайпдеф, когда уже есть достаточный объём кода, в котором без объявления тайпдефа писать становится напряжно(например появляются методы в которых 10 аргументов QString, при этом часть этих QString идентификаторы одного рода объектов, а другие QString - других,или постоянно приходится создавать шаблонные классы с одним и тем же параметром). Если модуль используется в конечной программе в одном месте и от него не зависят другие модули, то от абстракции через тайпдефы лучше отказаться. Это замечание касается, например, StatisticsValue и StatisticsValueList.

В коммите e2a09d18240e92dee20d3125ed897e63b13bf49b глобальное изменение - вынос в всех Q_DECLARE_METATYPE в один файл. Я не могу сказать, есть у этого решения какие-то негативные последтсвия(например, скорость сборки или необходимость везде указывать прототипы классов для устранения циклических инклудов). Но это изменение не описано в тексте коммита.

Не понимаю, почему в тестах TAnalysisTableModel::TestSorting нельзя было напрямую использовать Qt::SortOrder для создания тестовых данных.

Адский метод AnalysisTableModel::sort. Для сортировки по айдишникам был грамотно применён qSort. Почему нельзя было его же применить для сортировки по результатам анализов?

subLayout_1 не очень хорошее имя для переменой.

Почему все методы в PointListGenerator называются generateConst? Кроме того, их вполне можно было сделать статическими. Вообще лучше выносить в статические методы всё, что только можно вынести, но при этом следить за как можно меньшим изменением значения статических полей, если они не консты.

В SqlPointListWriter::write
...
 if(!querySuccess)
{
	qWarning() << "exec insert table" << writePointsByID_.lastError().text();
	dataBase().commit();
	return;
}
...
Почему в случае ошибки нужно делать dataBase().commit()?




 